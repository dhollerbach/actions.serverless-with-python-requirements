import { loadRestJsonErrorCode, parseJsonBody as parseBody, parseJsonErrorBody as parseErrorBody } from "@aws-sdk/core";
import { requestBuilder as rb } from "@smithy/core";
import { _json, collectBody, convertMap, decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectObject as __expectObject, expectString as __expectString, isSerializableHeaderValue, limitedParseDouble as __limitedParseDouble, map, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, take, withBaseException, } from "@smithy/smithy-client";
import { APIGatewayServiceException as __BaseException } from "../models/APIGatewayServiceException";
import { BadRequestException, ConflictException, LimitExceededException, NotFoundException, ServiceUnavailableException, TooManyRequestsException, UnauthorizedException, } from "../models/models_0";
export const se_CreateApiKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/apikeys");
    let body;
    body = JSON.stringify(take(input, {
        customerId: [],
        description: [],
        enabled: [],
        generateDistinctId: [],
        name: [],
        stageKeys: (_) => _json(_),
        tags: (_) => _json(_),
        value: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/authorizers");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        authType: [],
        authorizerCredentials: [],
        authorizerResultTtlInSeconds: [],
        authorizerUri: [],
        identitySource: [],
        identityValidationExpression: [],
        name: [],
        providerARNs: (_) => _json(_),
        type: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateBasePathMappingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainnames/{domainName}/basepathmappings");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        basePath: [],
        restApiId: [],
        stage: [],
    }));
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_CreateDeploymentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/deployments");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        cacheClusterEnabled: [],
        cacheClusterSize: [],
        canarySettings: (_) => se_DeploymentCanarySettings(_, context),
        description: [],
        stageDescription: [],
        stageName: [],
        tracingEnabled: [],
        variables: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDocumentationPartCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/documentation/parts");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        location: (_) => _json(_),
        properties: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDocumentationVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/documentation/versions");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        documentationVersion: [],
        stageName: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDomainNameCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainnames");
    let body;
    body = JSON.stringify(take(input, {
        certificateArn: [],
        certificateBody: [],
        certificateChain: [],
        certificateName: [],
        certificatePrivateKey: [],
        domainName: [],
        endpointConfiguration: (_) => _json(_),
        mutualTlsAuthentication: (_) => _json(_),
        ownershipVerificationCertificateArn: [],
        policy: [],
        regionalCertificateArn: [],
        regionalCertificateName: [],
        securityPolicy: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateDomainNameAccessAssociationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainnameaccessassociations");
    let body;
    body = JSON.stringify(take(input, {
        accessAssociationSource: [],
        accessAssociationSourceType: [],
        domainNameArn: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/models");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentType: [],
        description: [],
        name: [],
        schema: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateRequestValidatorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/requestvalidators");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        name: [],
        validateRequestBody: [],
        validateRequestParameters: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{parentId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("parentId", () => input.parentId, "{parentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        pathPart: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateRestApiCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis");
    let body;
    body = JSON.stringify(take(input, {
        apiKeySource: [],
        binaryMediaTypes: (_) => _json(_),
        cloneFrom: [],
        description: [],
        disableExecuteApiEndpoint: [],
        endpointConfiguration: (_) => _json(_),
        minimumCompressionSize: [],
        name: [],
        policy: [],
        tags: (_) => _json(_),
        version: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateStageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/stages");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        cacheClusterEnabled: [],
        cacheClusterSize: [],
        canarySettings: (_) => se_CanarySettings(_, context),
        deploymentId: [],
        description: [],
        documentationVersion: [],
        stageName: [],
        tags: (_) => _json(_),
        tracingEnabled: [],
        variables: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateUsagePlanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/usageplans");
    let body;
    body = JSON.stringify(take(input, {
        apiStages: (_) => se_ListOfApiStage(_, context),
        description: [],
        name: [],
        quota: (_) => _json(_),
        tags: (_) => _json(_),
        throttle: (_) => se_ThrottleSettings(_, context),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateUsagePlanKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/usageplans/{usagePlanId}/keys");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    body = JSON.stringify(take(input, {
        keyId: [],
        keyType: [],
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_CreateVpcLinkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/vpclinks");
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        name: [],
        tags: (_) => _json(_),
        targetArns: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_DeleteApiKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/apikeys/{apiKey}");
    b.p("apiKey", () => input.apiKey, "{apiKey}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/authorizers/{authorizerId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteBasePathMappingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnames/{domainName}/basepathmappings/{basePath}");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    b.p("basePath", () => input.basePath, "{basePath}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteClientCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/clientcertificates/{clientCertificateId}");
    b.p("clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDeploymentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/deployments/{deploymentId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("deploymentId", () => input.deploymentId, "{deploymentId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDocumentationPartCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/documentation/parts/{documentationPartId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDocumentationVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/documentation/versions/{documentationVersion}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteDomainNameCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnames/{domainName}");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_DeleteDomainNameAccessAssociationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnameaccessassociations/{domainNameAccessAssociationArn}");
    b.p("domainNameAccessAssociationArn", () => input.domainNameAccessAssociationArn, "{domainNameAccessAssociationArn}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteGatewayResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/gatewayresponses/{responseType}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("responseType", () => input.responseType, "{responseType}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteIntegrationResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteMethodCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteMethodResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/models/{modelName}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("modelName", () => input.modelName, "{modelName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteRequestValidatorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/requestvalidators/{requestValidatorId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteRestApiCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteStageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/stages/{stageName}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteUsagePlanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans/{usagePlanId}");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteUsagePlanKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans/{usagePlanId}/keys/{keyId}");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    b.p("keyId", () => input.keyId, "{keyId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_DeleteVpcLinkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/vpclinks/{vpcLinkId}");
    b.p("vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_FlushStageAuthorizersCacheCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/stages/{stageName}/cache/authorizers");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_FlushStageCacheCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/stages/{stageName}/cache/data");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    let body;
    b.m("DELETE").h(headers).b(body);
    return b.build();
};
export const se_GenerateClientCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/clientcertificates");
    let body;
    body = JSON.stringify(take(input, {
        description: [],
        tags: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_GetAccountCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/account");
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetApiKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/apikeys/{apiKey}");
    b.p("apiKey", () => input.apiKey, "{apiKey}", false);
    const query = map({
        [_iV]: [() => input.includeValue !== void 0, () => input[_iV].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetApiKeysCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/apikeys");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_n]: [, input[_nQ]],
        [_cI]: [, input[_cI]],
        [_iVn]: [() => input.includeValues !== void 0, () => input[_iVn].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/authorizers/{authorizerId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetAuthorizersCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/authorizers");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetBasePathMappingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnames/{domainName}/basepathmappings/{basePath}");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    b.p("basePath", () => input.basePath, "{basePath}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetBasePathMappingsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnames/{domainName}/basepathmappings");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetClientCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/clientcertificates/{clientCertificateId}");
    b.p("clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetClientCertificatesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/clientcertificates");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDeploymentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/deployments/{deploymentId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("deploymentId", () => input.deploymentId, "{deploymentId}", false);
    const query = map({
        [_e]: [() => input.embed !== void 0, () => input[_e] || []],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDeploymentsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/deployments");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDocumentationPartCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/documentation/parts/{documentationPartId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDocumentationPartsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/documentation/parts");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_t]: [, input[_t]],
        [_n]: [, input[_nQ]],
        [_pa]: [, input[_pa]],
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_lS]: [, input[_lS]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDocumentationVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/documentation/versions/{documentationVersion}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetDocumentationVersionsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/documentation/versions");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDomainNameCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnames/{domainName}");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDomainNameAccessAssociationsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnameaccessassociations");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_rO]: [, input[_rO]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetDomainNamesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/domainnames");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_rO]: [, input[_rO]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetExportCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = map({}, isSerializableHeaderValue, {
        [_ac]: input[_a],
    });
    b.bp("/restapis/{restApiId}/stages/{stageName}/exports/{exportType}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    b.p("exportType", () => input.exportType, "{exportType}", false);
    const query = map({
        ...convertMap(input.parameters),
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetGatewayResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/gatewayresponses/{responseType}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("responseType", () => input.responseType, "{responseType}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetGatewayResponsesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/gatewayresponses");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetIntegrationResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetMethodCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetMethodResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/models/{modelName}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("modelName", () => input.modelName, "{modelName}", false);
    const query = map({
        [_f]: [() => input.flatten !== void 0, () => input[_f].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetModelsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/models");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetModelTemplateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/models/{modelName}/default_template");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("modelName", () => input.modelName, "{modelName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetRequestValidatorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/requestvalidators/{requestValidatorId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetRequestValidatorsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/requestvalidators");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources/{resourceId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    const query = map({
        [_e]: [() => input.embed !== void 0, () => input[_e] || []],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetResourcesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/resources");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_e]: [() => input.embed !== void 0, () => input[_e] || []],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetRestApiCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetRestApisCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetSdkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/stages/{stageName}/sdks/{sdkType}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    b.p("sdkType", () => input.sdkType, "{sdkType}", false);
    const query = map({
        ...convertMap(input.parameters),
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetSdkTypeCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdktypes/{id}");
    b.p("id", () => input.id, "{id}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetSdkTypesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/sdktypes");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetStageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/stages/{stageName}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetStagesCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/restapis/{restApiId}/stages");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_dI]: [, input[_dI]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetTagsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetUsageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans/{usagePlanId}/usage");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    const query = map({
        [_kI]: [, input[_kI]],
        [_sD]: [, __expectNonNull(input[_sD], `startDate`)],
        [_eD]: [, __expectNonNull(input[_eD], `endDate`)],
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetUsagePlanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans/{usagePlanId}");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetUsagePlanKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans/{usagePlanId}/keys/{keyId}");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    b.p("keyId", () => input.keyId, "{keyId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetUsagePlanKeysCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans/{usagePlanId}/keys");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
        [_n]: [, input[_nQ]],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetUsagePlansCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/usageplans");
    const query = map({
        [_p]: [, input[_p]],
        [_kI]: [, input[_kI]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_GetVpcLinkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/vpclinks/{vpcLinkId}");
    b.p("vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    b.m("GET").h(headers).b(body);
    return b.build();
};
export const se_GetVpcLinksCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/vpclinks");
    const query = map({
        [_p]: [, input[_p]],
        [_l]: [() => input.limit !== void 0, () => input[_l].toString()],
    });
    let body;
    b.m("GET").h(headers).q(query).b(body);
    return b.build();
};
export const se_ImportApiKeysCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/octet-stream",
    };
    b.bp("/apikeys");
    const query = map({
        [_m]: [, "import"],
        [_fo]: [, __expectNonNull(input[_fo], `format`)],
        [_fa]: [() => input.failOnWarnings !== void 0, () => input[_fOW].toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_ImportDocumentationPartsCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/octet-stream",
    };
    b.bp("/restapis/{restApiId}/documentation/parts");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        [_m]: [, input[_m]],
        [_fa]: [() => input.failOnWarnings !== void 0, () => input[_fOW].toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_ImportRestApiCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/octet-stream",
    };
    b.bp("/restapis");
    const query = map({
        [_m]: [, "import"],
        ...convertMap(input.parameters),
        [_fa]: [() => input.failOnWarnings !== void 0, () => input[_fOW].toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_PutGatewayResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/gatewayresponses/{responseType}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("responseType", () => input.responseType, "{responseType}", false);
    let body;
    body = JSON.stringify(take(input, {
        responseParameters: (_) => _json(_),
        responseTemplates: (_) => _json(_),
        statusCode: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        cacheKeyParameters: (_) => _json(_),
        cacheNamespace: [],
        connectionId: [],
        connectionType: [],
        contentHandling: [],
        credentials: [],
        httpMethod: [, , `integrationHttpMethod`],
        passthroughBehavior: [],
        requestParameters: (_) => _json(_),
        requestTemplates: (_) => _json(_),
        timeoutInMillis: [],
        tlsConfig: (_) => _json(_),
        type: [],
        uri: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutIntegrationResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        contentHandling: [],
        responseParameters: (_) => _json(_),
        responseTemplates: (_) => _json(_),
        selectionPattern: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutMethodCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        apiKeyRequired: [],
        authorizationScopes: (_) => _json(_),
        authorizationType: [],
        authorizerId: [],
        operationName: [],
        requestModels: (_) => _json(_),
        requestParameters: (_) => _json(_),
        requestValidatorId: [],
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutMethodResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        responseModels: (_) => _json(_),
        responseParameters: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_PutRestApiCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/octet-stream",
    };
    b.bp("/restapis/{restApiId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    const query = map({
        ...convertMap(input.parameters),
        [_m]: [, input[_m]],
        [_fa]: [() => input.failOnWarnings !== void 0, () => input[_fOW].toString()],
    });
    let body;
    if (input.body !== undefined) {
        body = input.body;
    }
    b.m("PUT").h(headers).q(query).b(body);
    return b.build();
};
export const se_RejectDomainNameAccessAssociationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/rejectdomainnameaccessassociations");
    const query = map({
        [_dNAAA]: [, __expectNonNull(input[_dNAAA], `domainNameAccessAssociationArn`)],
        [_dNA]: [, __expectNonNull(input[_dNA], `domainNameArn`)],
    });
    let body;
    b.m("POST").h(headers).q(query).b(body);
    return b.build();
};
export const se_TagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    let body;
    body = JSON.stringify(take(input, {
        tags: (_) => _json(_),
    }));
    b.m("PUT").h(headers).b(body);
    return b.build();
};
export const se_TestInvokeAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/authorizers/{authorizerId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    body = JSON.stringify(take(input, {
        additionalContext: (_) => _json(_),
        body: [],
        headers: (_) => _json(_),
        multiValueHeaders: (_) => _json(_),
        pathWithQueryString: [],
        stageVariables: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_TestInvokeMethodCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        body: [],
        clientCertificateId: [],
        headers: (_) => _json(_),
        multiValueHeaders: (_) => _json(_),
        pathWithQueryString: [],
        stageVariables: (_) => _json(_),
    }));
    b.m("POST").h(headers).b(body);
    return b.build();
};
export const se_UntagResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {};
    b.bp("/tags/{resourceArn}");
    b.p("resourceArn", () => input.resourceArn, "{resourceArn}", false);
    const query = map({
        [_tK]: [__expectNonNull(input.tagKeys, `tagKeys`) != null, () => input[_tK] || []],
    });
    let body;
    b.m("DELETE").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateAccountCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/account");
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateApiKeyCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/apikeys/{apiKey}");
    b.p("apiKey", () => input.apiKey, "{apiKey}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateAuthorizerCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/authorizers/{authorizerId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("authorizerId", () => input.authorizerId, "{authorizerId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateBasePathMappingCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainnames/{domainName}/basepathmappings/{basePath}");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    b.p("basePath", () => input.basePath, "{basePath}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateClientCertificateCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/clientcertificates/{clientCertificateId}");
    b.p("clientCertificateId", () => input.clientCertificateId, "{clientCertificateId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDeploymentCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/deployments/{deploymentId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("deploymentId", () => input.deploymentId, "{deploymentId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDocumentationPartCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/documentation/parts/{documentationPartId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("documentationPartId", () => input.documentationPartId, "{documentationPartId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDocumentationVersionCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/documentation/versions/{documentationVersion}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("documentationVersion", () => input.documentationVersion, "{documentationVersion}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateDomainNameCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/domainnames/{domainName}");
    b.p("domainName", () => input.domainName, "{domainName}", false);
    const query = map({
        [_dNI]: [, input[_dNI]],
    });
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).q(query).b(body);
    return b.build();
};
export const se_UpdateGatewayResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/gatewayresponses/{responseType}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("responseType", () => input.responseType, "{responseType}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateIntegrationCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateIntegrationResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/integration/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateMethodCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateMethodResponseCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}/methods/{httpMethod}/responses/{statusCode}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    b.p("httpMethod", () => input.httpMethod, "{httpMethod}", false);
    b.p("statusCode", () => input.statusCode, "{statusCode}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateModelCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/models/{modelName}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("modelName", () => input.modelName, "{modelName}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateRequestValidatorCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/requestvalidators/{requestValidatorId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("requestValidatorId", () => input.requestValidatorId, "{requestValidatorId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateResourceCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/resources/{resourceId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("resourceId", () => input.resourceId, "{resourceId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateRestApiCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateStageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/restapis/{restApiId}/stages/{stageName}");
    b.p("restApiId", () => input.restApiId, "{restApiId}", false);
    b.p("stageName", () => input.stageName, "{stageName}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateUsageCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/usageplans/{usagePlanId}/keys/{keyId}/usage");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    b.p("keyId", () => input.keyId, "{keyId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateUsagePlanCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/usageplans/{usagePlanId}");
    b.p("usagePlanId", () => input.usagePlanId, "{usagePlanId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const se_UpdateVpcLinkCommand = async (input, context) => {
    const b = rb(input, context);
    const headers = {
        "content-type": "application/json",
    };
    b.bp("/vpclinks/{vpcLinkId}");
    b.p("vpcLinkId", () => input.vpcLinkId, "{vpcLinkId}", false);
    let body;
    body = JSON.stringify(take(input, {
        patchOperations: (_) => _json(_),
    }));
    b.m("PATCH").h(headers).b(body);
    return b.build();
};
export const de_CreateApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authType: __expectString,
        authorizerCredentials: __expectString,
        authorizerResultTtlInSeconds: __expectInt32,
        authorizerUri: __expectString,
        id: __expectString,
        identitySource: __expectString,
        identityValidationExpression: __expectString,
        name: __expectString,
        providerARNs: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        basePath: __expectString,
        restApiId: __expectString,
        stage: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        location: _json,
        properties: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameArn: __expectString,
        domainNameId: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        managementPolicy: __expectString,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        policy: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateDomainNameAccessAssociationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessAssociationSource: __expectString,
        accessAssociationSourceType: __expectString,
        domainNameAccessAssociationArn: __expectString,
        domainNameArn: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateModelCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentType: __expectString,
        description: __expectString,
        id: __expectString,
        name: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        validateRequestBody: __expectBoolean,
        validateRequestParameters: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateResourceCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        parentId: __expectString,
        path: __expectString,
        pathPart: __expectString,
        resourceMethods: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateRestApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateStageCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        type: __expectString,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_CreateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        id: __expectString,
        name: __expectString,
        status: __expectString,
        statusMessage: __expectString,
        tags: _json,
        targetArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_DeleteApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteDomainNameAccessAssociationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteMethodCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteModelCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteResourceCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteRestApiCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteStageCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_DeleteVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_FlushStageAuthorizersCacheCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_FlushStageCacheCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_GenerateClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyVersion: __expectString,
        cloudwatchRoleArn: __expectString,
        features: _json,
        throttleSettings: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetApiKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfApiKey(_, context), `item`],
        position: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authType: __expectString,
        authorizerCredentials: __expectString,
        authorizerResultTtlInSeconds: __expectInt32,
        authorizerUri: __expectString,
        id: __expectString,
        identitySource: __expectString,
        identityValidationExpression: __expectString,
        name: __expectString,
        providerARNs: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetAuthorizersCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        basePath: __expectString,
        restApiId: __expectString,
        stage: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetBasePathMappingsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetClientCertificatesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfClientCertificate(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDeploymentsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfDeployment(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        location: _json,
        properties: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentationPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDocumentationVersionsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfDocumentationVersion(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameArn: __expectString,
        domainNameId: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        managementPolicy: __expectString,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        policy: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainNameAccessAssociationsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetDomainNamesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfDomainName(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetExportCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_cT]: [, output.headers[_ct]],
        [_cD]: [, output.headers[_cd]],
    });
    const data = await collectBody(output.body, context);
    contents.body = data;
    return contents;
};
export const de_GetGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultResponse: __expectBoolean,
        responseParameters: _json,
        responseTemplates: _json,
        responseType: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetGatewayResponsesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cacheKeyParameters: _json,
        cacheNamespace: __expectString,
        connectionId: __expectString,
        connectionType: __expectString,
        contentHandling: __expectString,
        credentials: __expectString,
        httpMethod: __expectString,
        integrationResponses: _json,
        passthroughBehavior: __expectString,
        requestParameters: _json,
        requestTemplates: _json,
        timeoutInMillis: __expectInt32,
        tlsConfig: _json,
        type: __expectString,
        uri: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentHandling: __expectString,
        responseParameters: _json,
        responseTemplates: _json,
        selectionPattern: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyRequired: __expectBoolean,
        authorizationScopes: _json,
        authorizationType: __expectString,
        authorizerId: __expectString,
        httpMethod: __expectString,
        methodIntegration: _json,
        methodResponses: _json,
        operationName: __expectString,
        requestModels: _json,
        requestParameters: _json,
        requestValidatorId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        responseModels: _json,
        responseParameters: _json,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentType: __expectString,
        description: __expectString,
        id: __expectString,
        name: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetModelsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetModelTemplateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        validateRequestBody: __expectBoolean,
        validateRequestParameters: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetRequestValidatorsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        parentId: __expectString,
        path: __expectString,
        pathPart: __expectString,
        resourceMethods: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetResourcesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetRestApisCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfRestApi(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSdkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
        [_cT]: [, output.headers[_ct]],
        [_cD]: [, output.headers[_cd]],
    });
    const data = await collectBody(output.body, context);
    contents.body = data;
    return contents;
};
export const de_GetSdkTypeCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        configurationProperties: _json,
        description: __expectString,
        friendlyName: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetSdkTypesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetStagesCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        item: (_) => de_ListOfStage(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetTagsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUsageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endDate: __expectString,
        items: [, _json, `values`],
        position: __expectString,
        startDate: __expectString,
        usagePlanId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUsagePlanKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        type: __expectString,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUsagePlanKeysCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetUsagePlansCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, (_) => de_ListOfUsagePlan(_, context), `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        id: __expectString,
        name: __expectString,
        status: __expectString,
        statusMessage: __expectString,
        tags: _json,
        targetArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_GetVpcLinksCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        items: [, _json, `item`],
        position: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ImportApiKeysCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ids: _json,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ImportDocumentationPartsCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        ids: _json,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_ImportRestApiCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultResponse: __expectBoolean,
        responseParameters: _json,
        responseTemplates: _json,
        responseType: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cacheKeyParameters: _json,
        cacheNamespace: __expectString,
        connectionId: __expectString,
        connectionType: __expectString,
        contentHandling: __expectString,
        credentials: __expectString,
        httpMethod: __expectString,
        integrationResponses: _json,
        passthroughBehavior: __expectString,
        requestParameters: _json,
        requestTemplates: _json,
        timeoutInMillis: __expectInt32,
        tlsConfig: _json,
        type: __expectString,
        uri: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentHandling: __expectString,
        responseParameters: _json,
        responseTemplates: _json,
        selectionPattern: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutMethodCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyRequired: __expectBoolean,
        authorizationScopes: _json,
        authorizationType: __expectString,
        authorizerId: __expectString,
        httpMethod: __expectString,
        methodIntegration: _json,
        methodResponses: _json,
        operationName: __expectString,
        requestModels: _json,
        requestParameters: _json,
        requestValidatorId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        responseModels: _json,
        responseParameters: _json,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_PutRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_RejectDomainNameAccessAssociationCommand = async (output, context) => {
    if (output.statusCode !== 202 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_TestInvokeAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authorization: _json,
        claims: _json,
        clientStatus: __expectInt32,
        latency: __expectLong,
        log: __expectString,
        policy: __expectString,
        principalId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_TestInvokeMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        body: __expectString,
        headers: _json,
        latency: __expectLong,
        log: __expectString,
        multiValueHeaders: _json,
        status: __expectInt32,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UntagResourceCommand = async (output, context) => {
    if (output.statusCode !== 204 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    await collectBody(output.body, context);
    return contents;
};
export const de_UpdateAccountCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyVersion: __expectString,
        cloudwatchRoleArn: __expectString,
        features: _json,
        throttleSettings: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateApiKeyCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateAuthorizerCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        authType: __expectString,
        authorizerCredentials: __expectString,
        authorizerResultTtlInSeconds: __expectInt32,
        authorizerUri: __expectString,
        id: __expectString,
        identitySource: __expectString,
        identityValidationExpression: __expectString,
        name: __expectString,
        providerARNs: _json,
        type: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateBasePathMappingCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        basePath: __expectString,
        restApiId: __expectString,
        stage: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateClientCertificateCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDeploymentCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDocumentationPartCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        location: _json,
        properties: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDocumentationVersionCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateDomainNameCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameArn: __expectString,
        domainNameId: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        managementPolicy: __expectString,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        policy: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateGatewayResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        defaultResponse: __expectBoolean,
        responseParameters: _json,
        responseTemplates: _json,
        responseType: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateIntegrationCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        cacheKeyParameters: _json,
        cacheNamespace: __expectString,
        connectionId: __expectString,
        connectionType: __expectString,
        contentHandling: __expectString,
        credentials: __expectString,
        httpMethod: __expectString,
        integrationResponses: _json,
        passthroughBehavior: __expectString,
        requestParameters: _json,
        requestTemplates: _json,
        timeoutInMillis: __expectInt32,
        tlsConfig: _json,
        type: __expectString,
        uri: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateIntegrationResponseCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentHandling: __expectString,
        responseParameters: _json,
        responseTemplates: _json,
        selectionPattern: __expectString,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateMethodCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeyRequired: __expectBoolean,
        authorizationScopes: _json,
        authorizationType: __expectString,
        authorizerId: __expectString,
        httpMethod: __expectString,
        methodIntegration: _json,
        methodResponses: _json,
        operationName: __expectString,
        requestModels: _json,
        requestParameters: _json,
        requestValidatorId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateMethodResponseCommand = async (output, context) => {
    if (output.statusCode !== 201 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        responseModels: _json,
        responseParameters: _json,
        statusCode: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateModelCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        contentType: __expectString,
        description: __expectString,
        id: __expectString,
        name: __expectString,
        schema: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateRequestValidatorCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        name: __expectString,
        validateRequestBody: __expectBoolean,
        validateRequestParameters: __expectBoolean,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateResourceCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        id: __expectString,
        parentId: __expectString,
        path: __expectString,
        pathPart: __expectString,
        resourceMethods: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateRestApiCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateStageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateUsageCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        endDate: __expectString,
        items: [, _json, `values`],
        position: __expectString,
        startDate: __expectString,
        usagePlanId: __expectString,
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateUsagePlanCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
    Object.assign(contents, doc);
    return contents;
};
export const de_UpdateVpcLinkCommand = async (output, context) => {
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CommandError(output, context);
    }
    const contents = map({
        $metadata: deserializeMetadata(output),
    });
    const data = __expectNonNull(__expectObject(await parseBody(output.body, context)), "body");
    const doc = take(data, {
        description: __expectString,
        id: __expectString,
        name: __expectString,
        status: __expectString,
        statusMessage: __expectString,
        tags: _json,
        targetArns: _json,
    });
    Object.assign(contents, doc);
    return contents;
};
const de_CommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "BadRequestException":
        case "com.amazonaws.apigateway#BadRequestException":
            throw await de_BadRequestExceptionRes(parsedOutput, context);
        case "ConflictException":
        case "com.amazonaws.apigateway#ConflictException":
            throw await de_ConflictExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.apigateway#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotFoundException":
        case "com.amazonaws.apigateway#NotFoundException":
            throw await de_NotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.apigateway#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.apigateway#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "ServiceUnavailableException":
        case "com.amazonaws.apigateway#ServiceUnavailableException":
            throw await de_ServiceUnavailableExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode,
            });
    }
};
const throwDefaultError = withBaseException(__BaseException);
const de_BadRequestExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new BadRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ConflictExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [, parsedOutput.headers[_ra]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_NotFoundExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new NotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_ServiceUnavailableExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [, parsedOutput.headers[_ra]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new ServiceUnavailableException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context) => {
    const contents = map({
        [_rAS]: [, parsedOutput.headers[_ra]],
    });
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context) => {
    const contents = map({});
    const data = parsedOutput.body;
    const doc = take(data, {
        message: __expectString,
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents,
    });
    return __decorateServiceException(exception, parsedOutput.body);
};
const se_ApiStage = (input, context) => {
    return take(input, {
        apiId: [],
        stage: [],
        throttle: (_) => se_MapOfApiStageThrottleSettings(_, context),
    });
};
const se_CanarySettings = (input, context) => {
    return take(input, {
        deploymentId: [],
        percentTraffic: __serializeFloat,
        stageVariableOverrides: _json,
        useStageCache: [],
    });
};
const se_DeploymentCanarySettings = (input, context) => {
    return take(input, {
        percentTraffic: __serializeFloat,
        stageVariableOverrides: _json,
        useStageCache: [],
    });
};
const se_ListOfApiStage = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return se_ApiStage(entry, context);
    });
};
const se_MapOfApiStageThrottleSettings = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = se_ThrottleSettings(value, context);
        return acc;
    }, {});
};
const se_ThrottleSettings = (input, context) => {
    return take(input, {
        burstLimit: [],
        rateLimit: __serializeFloat,
    });
};
const de_ApiKey = (output, context) => {
    return take(output, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        customerId: __expectString,
        description: __expectString,
        enabled: __expectBoolean,
        id: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        name: __expectString,
        stageKeys: _json,
        tags: _json,
        value: __expectString,
    });
};
const de_ApiStage = (output, context) => {
    return take(output, {
        apiId: __expectString,
        stage: __expectString,
        throttle: (_) => de_MapOfApiStageThrottleSettings(_, context),
    });
};
const de_CanarySettings = (output, context) => {
    return take(output, {
        deploymentId: __expectString,
        percentTraffic: __limitedParseDouble,
        stageVariableOverrides: _json,
        useStageCache: __expectBoolean,
    });
};
const de_ClientCertificate = (output, context) => {
    return take(output, {
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        expirationDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        pemEncodedCertificate: __expectString,
        tags: _json,
    });
};
const de_Deployment = (output, context) => {
    return take(output, {
        apiSummary: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        id: __expectString,
    });
};
const de_DocumentationVersion = (output, context) => {
    return take(output, {
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        version: __expectString,
    });
};
const de_DomainName = (output, context) => {
    return take(output, {
        certificateArn: __expectString,
        certificateName: __expectString,
        certificateUploadDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        distributionDomainName: __expectString,
        distributionHostedZoneId: __expectString,
        domainName: __expectString,
        domainNameArn: __expectString,
        domainNameId: __expectString,
        domainNameStatus: __expectString,
        domainNameStatusMessage: __expectString,
        endpointConfiguration: _json,
        managementPolicy: __expectString,
        mutualTlsAuthentication: _json,
        ownershipVerificationCertificateArn: __expectString,
        policy: __expectString,
        regionalCertificateArn: __expectString,
        regionalCertificateName: __expectString,
        regionalDomainName: __expectString,
        regionalHostedZoneId: __expectString,
        securityPolicy: __expectString,
        tags: _json,
    });
};
const de_ListOfApiKey = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiKey(entry, context);
    });
    return retVal;
};
const de_ListOfApiStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ApiStage(entry, context);
    });
    return retVal;
};
const de_ListOfClientCertificate = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_ClientCertificate(entry, context);
    });
    return retVal;
};
const de_ListOfDeployment = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Deployment(entry, context);
    });
    return retVal;
};
const de_ListOfDocumentationVersion = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DocumentationVersion(entry, context);
    });
    return retVal;
};
const de_ListOfDomainName = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_DomainName(entry, context);
    });
    return retVal;
};
const de_ListOfRestApi = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_RestApi(entry, context);
    });
    return retVal;
};
const de_ListOfStage = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_Stage(entry, context);
    });
    return retVal;
};
const de_ListOfUsagePlan = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        return de_UsagePlan(entry, context);
    });
    return retVal;
};
const de_MapOfApiStageThrottleSettings = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_ThrottleSettings(value, context);
        return acc;
    }, {});
};
const de_MapOfMethodSettings = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = de_MethodSetting(value, context);
        return acc;
    }, {});
};
const de_MethodSetting = (output, context) => {
    return take(output, {
        cacheDataEncrypted: __expectBoolean,
        cacheTtlInSeconds: __expectInt32,
        cachingEnabled: __expectBoolean,
        dataTraceEnabled: __expectBoolean,
        loggingLevel: __expectString,
        metricsEnabled: __expectBoolean,
        requireAuthorizationForCacheControl: __expectBoolean,
        throttlingBurstLimit: __expectInt32,
        throttlingRateLimit: __limitedParseDouble,
        unauthorizedCacheControlHeaderStrategy: __expectString,
    });
};
const de_RestApi = (output, context) => {
    return take(output, {
        apiKeySource: __expectString,
        binaryMediaTypes: _json,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        description: __expectString,
        disableExecuteApiEndpoint: __expectBoolean,
        endpointConfiguration: _json,
        id: __expectString,
        minimumCompressionSize: __expectInt32,
        name: __expectString,
        policy: __expectString,
        rootResourceId: __expectString,
        tags: _json,
        version: __expectString,
        warnings: _json,
    });
};
const de_Stage = (output, context) => {
    return take(output, {
        accessLogSettings: _json,
        cacheClusterEnabled: __expectBoolean,
        cacheClusterSize: __expectString,
        cacheClusterStatus: __expectString,
        canarySettings: (_) => de_CanarySettings(_, context),
        clientCertificateId: __expectString,
        createdDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        deploymentId: __expectString,
        description: __expectString,
        documentationVersion: __expectString,
        lastUpdatedDate: (_) => __expectNonNull(__parseEpochTimestamp(__expectNumber(_))),
        methodSettings: (_) => de_MapOfMethodSettings(_, context),
        stageName: __expectString,
        tags: _json,
        tracingEnabled: __expectBoolean,
        variables: _json,
        webAclArn: __expectString,
    });
};
const de_ThrottleSettings = (output, context) => {
    return take(output, {
        burstLimit: __expectInt32,
        rateLimit: __limitedParseDouble,
    });
};
const de_UsagePlan = (output, context) => {
    return take(output, {
        apiStages: (_) => de_ListOfApiStage(_, context),
        description: __expectString,
        id: __expectString,
        name: __expectString,
        productCode: __expectString,
        quota: _json,
        tags: _json,
        throttle: (_) => de_ThrottleSettings(_, context),
    });
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const _a = "accepts";
const _ac = "accept";
const _cD = "contentDisposition";
const _cI = "customerId";
const _cT = "contentType";
const _cd = "content-disposition";
const _ct = "content-type";
const _dI = "deploymentId";
const _dNA = "domainNameArn";
const _dNAAA = "domainNameAccessAssociationArn";
const _dNI = "domainNameId";
const _e = "embed";
const _eD = "endDate";
const _f = "flatten";
const _fOW = "failOnWarnings";
const _fa = "failonwarnings";
const _fo = "format";
const _iV = "includeValue";
const _iVn = "includeValues";
const _kI = "keyId";
const _l = "limit";
const _lS = "locationStatus";
const _m = "mode";
const _n = "name";
const _nQ = "nameQuery";
const _p = "position";
const _pa = "path";
const _rAS = "retryAfterSeconds";
const _rO = "resourceOwner";
const _ra = "retry-after";
const _sD = "startDate";
const _t = "type";
const _tK = "tagKeys";
