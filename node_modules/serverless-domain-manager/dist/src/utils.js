"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.evaluateBoolean = evaluateBoolean;
exports.sleep = sleep;
exports.getAWSPagedResults = getAWSPagedResults;
const globals_1 = __importDefault(require("./globals"));
/**
 * Stops event thread execution for given number of seconds.
 * @param seconds
 * @returns {Promise<void>} Resolves after given number of seconds.
 */
function sleep(seconds) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve) => setTimeout(resolve, 1000 * seconds));
    });
}
/**
 * Determines whether this boolean config is configured to true or false.
 *
 * This method evaluates a customDomain property to see if it's true or false.
 * If the property's value is undefined, the default value is returned.
 * If the property's value is provided, this should be boolean, or a string parseable as boolean,
 * otherwise an exception is thrown.
 * @param {boolean|string} value the config value provided
 * @param {boolean} defaultValue the default value to return, if config value is undefined
 * @returns {boolean} the parsed boolean from the config value, or the default value
 */
function evaluateBoolean(value, defaultValue) {
    if (value === undefined) {
        return defaultValue;
    }
    const s = value.toString().toLowerCase().trim();
    const trueValues = ["true", "1"];
    const falseValues = ["false", "0"];
    if (trueValues.indexOf(s) >= 0) {
        return true;
    }
    if (falseValues.indexOf(s) >= 0) {
        return false;
    }
    throw new Error(`${globals_1.default.pluginName}: Ambiguous boolean config: "${value}"`);
}
/**
 * Iterate through the pages of a AWS SDK response and collect them into a single array
 *
 * @param client - The AWS service instance to use to make the calls
 * @param resultsKey - The key name in the response that contains the items to return
 * @param nextTokenKey - The request key name to append to the request that has the paging token value
 * @param nextRequestTokenKey - The response key name that has the next paging token value
 * @param params - Parameters to send in the request
 */
function getAWSPagedResults(client, resultsKey, nextTokenKey, nextRequestTokenKey, params) {
    return __awaiter(this, void 0, void 0, function* () {
        let results = [];
        let response = yield client.send(params);
        results = results.concat(response[resultsKey] || results);
        while ((nextRequestTokenKey in response) && response[nextRequestTokenKey]) {
            params.input[nextTokenKey] = response[nextRequestTokenKey];
            response = yield client.send(params);
            results = results.concat(response[resultsKey]);
        }
        return results;
    });
}
